% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flatline.R
\name{flatline}
\alias{flatline}
\title{(Internal) implementation of the flatline forecaster}
\usage{
flatline(formula, data)
}
\arguments{
\item{formula}{The lhs should be a single variable. In standard usage, this
would actually be the observed time series shifted forward by the forecast
horizon. The right hand side must contain any keys (locations) for the
panel data separated by plus. The observed time series must come last.
For example

\if{html}{\out{<div class="sourceCode r">}}\preformatted{form <- as.formula(lead7_y ~ state + age + y)
}\if{html}{\out{</div>}}

Note that this function doesn't DO the shifting, that has to be done
outside.}

\item{data}{A data frame containing at least the variables used in the
formula. It must also contain a column \code{time_value} giving the observed
time points.}
}
\value{
An S3 object of class \code{flatline} with two components:
\itemize{
\item \code{residuals} - a tibble with all keys and a \code{.resid} column that contains
forecast errors.
\item \code{.pred} - a tibble with all keys and a \code{.pred} column containing only
predictions for future data (the last observed of the outcome for each
combination of keys.
}
}
\description{
This is an internal function that is used to create a \code{\link[parsnip:linear_reg]{parsnip::linear_reg()}}
model. It has somewhat odd behaviour (see below).
}
\examples{
tib <- data.frame(
  y = runif(100),
  expand.grid(k = letters[1:4], j = letters[5:9], time_value = 1:5)
) \%>\%
  dplyr::group_by(k, j) \%>\%
  dplyr::mutate(y2 = dplyr::lead(y, 2)) # predict 2 steps ahead
flat <- flatline(y2 ~ j + k + y, tib) # predictions for 20 locations
sum(!is.na(flat$residuals$.resid)) # 100 residuals, but 40 are NA
}
\keyword{internal}
